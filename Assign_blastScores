#!/usr/bin/env python
'''
    Assign_blastScores program accepts the following three inputs:
           (1) a blast results file 
           (3) an optional output file name to store blast scores 
    How to run this program?
    Mode 1: 
       > python Assign_blastScores -I1=blast_results.txt
    Mode 2: 
       > python Assign_blastScores -I1=blast_results.txt -O=blast_scores.txt
'''
import os
import sys
from os.path import basename 

from Ontology.IO import OboIO

import configparser as cp
import shutil
import subprocess

import ArgParser_assign_blastScores as ap

import Config
import xTract_sp_trainingSet as xt
import FormatChecker as fc
import LocateDataset as ld

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Default configuration file name:
config_filename = '.cafarc' 

class Assign_blastScores: 
    def __init__(self):
        # Collect user arguments into a dictionary:
        self.parsed_dict = ap.parse_args()

        # Collect config file entries:
        self.ConfigParam = Config.read_config(config_filename) 
        self.work_dir = self.ConfigParam['workdir']


        # Look for workspace, and if none exists create one:
        if not os.path.exists(self.work_dir):
            os.makedirs(self.work_dir) # Create work space

        #t1 = self.parsed_dict['t1'] # Extract input file name
        #print(self.parsed_dict.keys())
        blast_results_fname = self.parsed_dict['blast_results'] # Extract input file name
        self.blast_results_fname = ld.locate_anyfile(blast_results_fname, self.work_dir)
        obo_fname = self.parsed_dict['obo_file'] # Extract input file name
        self.obo_fname = ld.locate_anyfile(obo_fname, self.work_dir)

        return None

        # Create output file names to store training sequences:
        self.trSet_LK_mfo = self.create_outfilename('LK_mfo')
        self.trSet_LK_bpo = self.create_outfilename('LK_bpo')
        self.trSet_LK_cco = self.create_outfilename('LK_cco')

        # Create output file name for mapping between SwissProt 
        self.trSet_LK_mfo_map = self.trSet_LK_mfo + '.map'
        self.trSet_LK_bpo_map = self.trSet_LK_bpo + '.map' 
        self.trSet_LK_cco_map = self.trSet_LK_cco + '.map'

    def create_outfilename(self, ontType):
        """ 
        Creates an output filename based on the output file prefix
        provided by the user and at the end returns the newly
        created output filename.
        """
        if not self.parsed_dict['outfile'] == '':
            if not basename(self.parsed_dict['g']):
                ob = basename(self.parsed_dict['outfile']) + '.tfa_' + ontType
            else:
                ob = basename(self.parsed_dict['outfile']) + '.%s.tfa_' \
                          % basename(self.parsed_dict['g']) + ontType
        else: # if output file name is NOT supplied, construct one:
            if not basename(self.parsed_dict['g']):
                ob = basename(self.parsed_dict['t1']) + '.tfa_' + ontType
            else: # if taxon id is supplied
                ob = basename(self.parsed_dict['t1']) + '.%s.tfa_' \
                          % basename(self.parsed_dict['g']) + ontType
                # output file name is constructed by appending '.taxon id.tfa'
                # as an extension
        index = 1
        while os.path.exists(self.work_dir + '/' + ob + '.' + str(index)):
            index = index + 1
        output_filename = self.work_dir + '/' + ob + '.' + str(index)
        return output_filename

    def create_iterator(self, infile):
        """ 
        Creates and returns an iterator object for an input a UniProt-GOA
        file along with a list of all field names contained in the
        UniProt-GOA file.
        """
        infile_handle = open(infile, 'r')
        iter_handle = GOA.gafiterator(infile_handle)
        for ingen in iter_handle:
            if len(ingen) == 17:
                GAFFIELDS = GOA.GAF20FIELDS
                break
            else:
                GAFFIELDS = GOA.GAF10FIELDS
                break
        infile_handle = open(infile, 'r')
        iter_handle = GOA.gafiterator(infile_handle)
        return iter_handle, GAFFIELDS

    def print_prolog(self):
        print ("*************************************************")
        print ("Running Assign_blastScore Tool!!!!!")
        print ('Following is a list of user supplied inputs:')
        for arg in self.parsed_dict:
            print (arg + ': ' + str(self.parsed_dict[arg]))
        print ('*********************************************\n')
        return None

    def print_epilog(self):
        print(bcolors.OKGREEN + 'The following output files are created: ' +
              bcolors.ENDC)
        if os.path.exists(self.trSet_LK_mfo) and os.path.exists(self.trSet_LK_mfo_map):
            print('    MFO-Training sequence file and the corresponding map file: ')
            print('         ' + basename(self.trSet_LK_mfo))
            print('         ' + basename(self.trSet_LK_mfo_map))
        if os.path.exists(self.trSet_LK_bpo) and os.path.exists(self.trSet_LK_bpo_map):
            print('    BPO-Training sequence file and the corresponding map file: ')
            print('         ' + basename(self.trSet_LK_bpo))
            print('         ' + basename(self.trSet_LK_bpo_map))
        if os.path.exists(self.trSet_LK_cco) and os.path.exists(self.trSet_LK_cco_map):
            print('    CCO-Training sequence file and the corresponding map file: ')
            print('         ' + basename(self.trSet_LK_cco))
            print('         ' + basename(self.trSet_LK_cco_map))
        print(bcolors.OKGREEN + 'Thank you for using Training Sequence Generation Tool' + \
               bcolors.ENDC)
        return None

    def check_sprot_format(self, sprot_fname):
        """
        This method exits the xTract_trainingSeq program on any of the
        following conditions:
            Case 1: if the file is empty
            Case 2: if the file is NOT in UniProtKB/SwissProt format.
                    To check this it invokes check_sprot_format method
                    of FormatChecker module.
        """
        if os.stat(sprot_fname).st_size == 0:
            print(bcolors.WARNING + 'You submitted an empty file: ' + sprot_fname + \
                  bcolors.ENDC)
            sys.exit(1)
        elif not fc.check_sprot_format(open(sprot_fname, 'r')):
            print(bcolors.WARNING + 'File format error: ' + \
                  basename(sprot_fname) + bcolors.ENDC)
            print(bcolors.WARNING + 'File must be in UniProtKB/SwissProt ' + \
                'format' + bcolors.ENDC)
            sys.exit(1)

    def build_ontology_annotation(self, obo_fname): 
        '''
        This method builds a directed acyclic graphi (DAG) as an 
        object of OntologyGraph class from a plain-text OBO file 
        and returns the DAG object.
        '''    
        # Create an OboReader object:
        obo_parser = OboIO.OboReader(open(obo_fname))
        # Obtain an instance of OntologyGraph class by invoking 
        # read method of OboReader class:
        og = obo_parser.read()
        return og    

    def model_blast(self): 
        
        print('inside model_blast method')

        return None

    def process_data(self):
        """
        This method invokes other methods to perform all tasks related
        to training sequence generation.
        """
        # Print the wellcome message:
        self.print_prolog()
        # Create ontogloyg graph object:
        og = self.build_ontology_annotation(self.obo_fname)
        ancestors = og.get_ancestors('GO:0000001')
        print(ancestors)

        # Check UniProtKB/SwissProt file format: 
        # self.check_sprot_format(self.t1_input_file)

        self.model_blast()         

        # Print the summary of running this program:
        #self.print_epilog()
        return None

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print(sys.argv[0] + ':')
        print(__doc__)
    else:
        fd = Assign_blastScores() # Create an instance of Assign_blastScores class
        fd.process_data() # Process data and assign blast scores 
    sys.exit(0)
