#!/usr/bin/env python
'''
    This tool count the number of genes for a set of organisms in
    some UniProtKB/SwissProt files over a series of time points.
    One can run this program as follows:

       > python Count_genes -I1=sprot_files.txt -I2=sp_list.txt
   
    The program will use the organisms from the sp_list.txt file
    and UniProtKB/SwissProt files from the sprot_files.txt file.
    The description of these input files are as follows:

         sp_list.txt: This file has the list of species: column 1
            has the taxon ids and column 2 has the taxon names.

        sprot_files.txt: This file has has the SwissProt filenames in the
            format uniprot_sprot.dat.yyyy_mm for example
            uniprot_sprot.data.2016_01 for the SwissProt file release in
            Januray 2016. The program extracts the time points from this file.
            Also, each entry in this file corresponds to the rows in
            sprot_genes.stat.1 file.

    The program will generate an output file sprot_genes.stat.1 whose 
    description is as follows:

        sprot_genes.stat.1: This file has the gene counts.
            Each row corresponds to the SwissProt file name listed
            in sprot_files.txt file. For each organism, there are
            three consecutive columns (for BPO, CCO, and MFO,
            respectively). The columns corresponds to the species
            listed in the sp_list.txt file, in the same order.
    
    Repeated run of this program will create the subsequent versions of 
    the output file.

    The program can also be supplied with an output filename prefix:

       > python Count_genes -I1=sprot_files.txt -I2=sp_list.txt -O=sprot_genes.stat
'''
import os
import sys
from os.path import basename 

import ArgParser_count as ap
import Config
import ConfigParser as cp
import Count_sp_genes as csg
import Download as dl
import FormatChecker as fc
import LocateDataset as ld

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Default configuration file name:
config_filename = '.config' 

output_fn_prefix = 'sprot_genes.stat'

class Count_genes:
    def __init__(self):
        # Collect user arguments into a dictionary:
        self.parsed_dict = ap.parse_args() 

        # Collect config file entries:
        self.ConfigParam = Config.read_config(config_filename) 
        self.work_dir = self.ConfigParam['workdir']

        # Look for workspace, and if none exists create one:
        if not os.path.exists(self.work_dir):
            os.makedirs(self.work_dir) # Create work space

        t1 = self.parsed_dict['t1'] # Extract input file name
        # Locate file for the species list:
        self.species_filename = ld.locate_anyfile(t1, self.work_dir)
        t2 = self.parsed_dict['t2'] # Extract input file name
        # Locate the file for the list of the UniProtKB/SwissProt 
        # file names over a series of time points:
        self.sprot_filename = ld.locate_anyfile(t2, self.work_dir)

        # Create output file name for saving gene counts:
        self.output_filename = self.create_outfilename() 
        return None

    def create_outfilename(self):
        """ 
        Creates an output filename based on the output file prefix
        provided by the user and at the end returns the newly
        created output filename.
        """
        if not self.parsed_dict['outfile'] == '':
            ob = basename(self.parsed_dict['outfile'])
        else:
            ob = output_fn_prefix
        index = 1
        while os.path.exists(self.work_dir + '/' + ob + '.' + str(index)):
            index = index + 1
        output_filename = self.work_dir + '/' + ob + '.' + str(index)
        return output_filename

    def check_sprot_format(self, sprot_fname):
        """
        This method exits the Filter program on any of the
        following conditions:
            Case 1: if the file is empty
            Case 2: if the file is NOT in UniProtKB/SwissProt format.
                    To check this it invokes check_sprot_format method
                    of FormatChecker module.
        """
        if os.stat(sprot_fname).st_size == 0:
            print bcolors.WARNING + 'You submitted an empty file: ' + sprot_fname + \
                  bcolors.ENDC
            sys.exit(1)
        elif not fc.check_sprot_format(open(sprot_fname, 'r')):
            print bcolors.WARNING + 'File format error: ' + \
                  basename(sprot_fname) + bcolors.ENDC
            print bcolors.WARNING + 'File must be in UniProtKB/SwissProt ' + \
                'format' + bcolors.ENDC
            sys.exit(1)

    def create_outfile_header(self):
        '''
        This method creates the TWO header lines for the output 
        file for writing gene counts for all species in SwissProt 
        files over a series of time points.
        '''
        sp_header = '\t'
        ont_header =''
        fh_sp = open(self.species_filename, 'r')
        # Skip the header line: 
        next(fh_sp)
        # Read each subsequent line of the species file 
        # and construct the two header lines:
        for line in fh_sp:
            sp_header += '\t' + line.strip().split('\t')[0] + '\t\t'
            ont_header += '\t' + 'BPO' + '\t' + 'CCO' + '\t' + 'MFO'
        sp_header = sp_header.rstrip() + '\n'
        ont_header = ont_header.rstrip() + '\n'
        return (sp_header, ont_header)

    def print_prolog(self):
        print "*************************************************"
        print "Welcome to Gene Count Tool !!!!!"
        print "*************************************************\n"
        print 'Following is a list of user supplied inputs:\n'
        for arg in self.parsed_dict:
            print arg + ': ' + str(self.parsed_dict[arg])
        print '*********************************************\n'
        return None

    def print_epilog(self):
        if os.path.exists(self.output_filename):
            print(bcolors.OKGREEN + 'The following gene count file ' + \
                                    'is created:' + bcolors.ENDC)
            print basename(self.output_filename)
        else: 
            print(bcolors.WARNING + 'No gene count file is created ' + \
                                    'with the given parameters' + bcolors.ENDC)
        print(bcolors.OKGREEN + 'Thank you for using Gene Count ' + \
                                'Tool' + bcolors.ENDC)
        return None

    def count_genes_for_species(self, sprot_fname):
        '''
        This method counts the number of experimentall annotated
        genes for all speceis in specific UniProtKB/SwissProt file 
        whose name is supplied by the argument sprot_fname. For each 
        speceis, the method calls count_genes_with_EXP method to count 
        the number of experimentally genes for that species in the 
        SwissProt file.
        '''
        # Initialize geneCount_str with the time stamp retrieved
        # from the UniProtKB/SwissProt filename:
        geneCount_str = basename(sprot_fname).strip().split('.dat.')[-1] + '\t'
        # Get a file handle for the species filename:
        fh_sp = open(self.species_filename, 'r')
        # Skip the first header line:
        next(fh_sp)
        # Calculate gene counts for each species in the
        # Swissprot file supplied by the file handle:
        for line in fh_sp:
            # Skip any empty line in the file with the organism name:
            if not (line.strip()):
                continue
            taxon_id = line.strip().split('\t')[0]
            print line.strip()
            gene_count = csg.count_genes_with_EXP(
                             open(sprot_fname, 'r'),
                             taxon_id,
                             self.ConfigParam['exp_eec'])

            print('Gene count in BPO ontology: ' + str(gene_count['BPO']))
            print('Gene count in CCO ontology: ' + str(gene_count['CCO']))
            print('Gene count in MFO ontology: ' + str(gene_count['CCO']))
            geneCount_str += str(gene_count['BPO']) + '\t' + \
                             str(gene_count['CCO']) + '\t' + \
                             str(gene_count['MFO']) + '\t'
        geneCount_str = geneCount_str.rstrip() + '\n'
        fh_sp.close()
        return geneCount_str

    def process_data(self):
        """
        This method repeatedly calls count_genes_for_species method 
        from Count_sp_genes.py module to count the genes that are 
        EXP validated in BPO, CCO, and MFO category, for all the 
        SwissProt files. 
        """
        # Print the wellcome message and argument list:
        self.print_prolog() 

        # Check the existence of data files and download that
        # are not available:

        # Create an object of Download class:
        dlObject = dl.Download(self.work_dir, self.sprot_filename)
        # Run the download_testDataset method which checks and 
        # downloads the data files listed in the self.sprot_filename:
        dlObject.download_testDataset(open(self.sprot_filename, 'r'))    
   
        # Create TWO header lines for the output file: 
        # sp_header: a string with species taxon ids
        # ont_header: a strings with BPO, CCO, MFO for each speceis
        sp_header, ont_header = self.create_outfile_header()

        # Create a file hanlde fh_out for the output file: 
        fh_out = open(self.output_filename, 'w')

        # Write the TWO header lines to the output file: 
        fh_out.write("%s" % sp_header)
        fh_out.write("%s" % ont_header)
        fh_out.flush()

        # Create a file handle fh_fn for the file containing the 
        # list of UniProtKB/SwissProt filenames:   
        fh_fn = open(self.sprot_filename, 'r')

        # Count the total number of genes with EXP evidence code 
        # for each UniProtKB/SwissProt file:
        for fname in fh_fn:
            # Skip any empty line in the file with the file names:
            if not (fname.strip()):
                continue
            # Retrieve the UniProtKB/SwissProt filename:
            sprot_fname = self.work_dir + '/' + fname.strip()
            # Create a string of gene counts for all species:
            geneCount_str = self.count_genes_for_species(sprot_fname)
            fh_out.write("%s" % geneCount_str)
            fh_out.flush()
        # Close the open file:
        fh_fn.close()
        fh_out.close()
        # Print summary of running this program:
        self.print_epilog()
        return None

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print (sys.argv[0] + ':')
        print(__doc__)
    else:
        cg = Count_genes()     # Create an instance of Count_gene class
        cg.process_data()      # Process data
    sys.exit(0)
