#!/usr/bin/env python
'''
    Count_genes program accepts the following three inputs:
           (1) a UniProtKB/swissProt file 
           (2) a taxon id and 
           (3) an optional output file name 

    When the output file name is NOT given, it will construct an output file
    name.

    How to run this program: 
        For some input file uniprot_sprot.dat.2014_09 and taxon id 559292

       > python Count_genes -I1=sprot_files.txt -I2=sp_list.txt
  
    The method creates one output file: 
        sprot_genes.stat.1: 
        For each UnirProtKB/SwissProt time point described in sprot_files, 
        the file has one line with gene counts for all species in sp_list.txt 
        file. 
'''
import os
import sys
from os.path import basename 

import ArgParser as ap
import Config
import ConfigParser as cp
import Count_sp_genes as csg
import Download as dl
import FormatChecker as fc
import LocateDataset as ld

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# Default configuration file name:
config_filename = '.config' 

output_fn_prefix = 'sprot_genes.stat'

class Count_genes:
    def __init__(self):
        # Collect user arguments into a dictionary:
        self.parsed_dict = ap.parse_args() 


        # Collect config file entries:
        self.ConfigParam = Config.read_config(config_filename) 
        self.work_dir = self.ConfigParam['workdir']

        # Look for workspace, and if none exists create one:
        if not os.path.exists(self.work_dir):
            os.makedirs(self.work_dir) # Create work space

        t1 = self.parsed_dict['t1'] # Extract input file name
        # Locate file for the species list:
        self.species_filename = ld.locate_anyfile(t1, self.work_dir)
        t2 = self.parsed_dict['t2'] # Extract input file name
        # Locate the file for the list of the UniProtKB/SwissProt 
        # file names over a series of time points:
        self.sprot_filename = ld.locate_anyfile(t2, self.work_dir)

        # Create output file name for target sequences:
        self.output_filename = self.create_outfilename() 
        return None

    def create_outfilename(self):
        """ 
        Creates an output filename based on the output file prefix
        provided by the user and at the end returns the newly
        created output filename.
        """
        if not self.parsed_dict['outfile'] == '':
            ob = basename(self.parsed_dict['outfile'])
        else:
            ob = output_fn_prefix
        index = 1
        while os.path.exists(self.work_dir + '/' + ob + '.' + str(index)):
            index = index + 1
        output_filename = self.work_dir + '/' + ob + '.' + str(index)
        return output_filename

    def check_sprot_format(self, sprot_fname):
        """
        This method exits the Filter program on any of the
        following conditions:
            Case 1: if the file is empty
            Case 2: if the file is NOT in UniProtKB/SwissProt format.
                    To check this it invokes check_sprot_format method
                    of FormatChecker module.
        """
        if os.stat(sprot_fname).st_size == 0:
            print bcolors.WARNING + 'You submitted an empty file: ' + sprot_fname + \
                  bcolors.ENDC
            sys.exit(1)
        elif not fc.check_sprot_format(open(sprot_fname, 'r')):
            print bcolors.WARNING + 'File format error: ' + \
                  basename(sprot_fname) + bcolors.ENDC
            print bcolors.WARNING + 'File must be in UniProtKB/SwissProt ' + \
                'format' + bcolors.ENDC
            sys.exit(1)

    def count_genes_for_species(self, sprot_fname):
        fh_sp = open(self.species_filename, 'r')
        # Initialize outstr with the time stamp part of the SwissProt filename 
        outstr = basename(sprot_fname).strip().split('.dat.')[-1] + '\t'
        print outstr
        count = 0
        for line in fh_sp:
            taxon_id = line.strip().split('\t')[0]
            print line.strip()
            exp_bpo_ct, exp_cco_ct, exp_mfo_ct = csg.count_genes_with_EXP(
                                                 open(sprot_fname, 'r'),
                                                 taxon_id,
                                                 self.ConfigParam['exp_eec'])

            print('exp_bpo_ct: ' + str(exp_bpo_ct))
            print('exp_cco_ct: ' + str(exp_cco_ct))
            print('exp_mfo_ct: ' + str(exp_mfo_ct))
            outstr += str(exp_bpo_ct) + '\t' + str(exp_cco_ct) + '\t' + str(exp_mfo_ct) + '\t'
            count += 1
#            if count > 0: 
#                break
        outstr = outstr.strip() + '\n'
        fh_sp.close()
        return outstr 

    def process_data(self):
        """
        This method repeatedly calls count_genes_for_species method 
        from Count_sp_genes.py module to count the genes that are 
        EXP validated in BPO, CCO, and MFO category, for all the 
        SwissProt files. 
        """
        # Check the existence of data files
        # If any data file is not found, download the data file
#        dlObject = dl.Download(self.work_dir, self.sprot_filename)
#        dlObject.download_testDataset(open(self.sprot_filename, 'r'))    

        # Count the total number of genes with EXP evidence code 
        # from the UniProtKB/SwissProt files:
#        self.count_genes_for_species()

        fh_out = open(self.output_filename, 'w')
        fh_fn = open(self.sprot_filename, 'r')
        count = 0
        for fname in fh_fn:
            sprot_fname = self.work_dir + '/' + fname.strip()
            outstr = self.count_genes_for_species(sprot_fname)
            fh_out.write("%s" % outstr)
            fh_out.flush()
            count += 1
#            if count > 1:
#                break
        fh_out.close()
        return None

if __name__ == '__main__':
    cg = Count_genes()     # Create an instance of Count_gene class
    cg.process_data()      # Process data
    sys.exit(0)
